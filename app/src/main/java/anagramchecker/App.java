/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package anagramchecker;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Map;
import lombok.SneakyThrows;

public class App {

  /**
   * There are 2 types of algorithmic approaches to solving this task:
   *
   * <p>1) Sort 2 arrays of chars and compare them.
   *
   * <p>In this case, we execute sorting twice. The complexity of sorting is O(n log(n)), but, we
   * don't need to allocate extra memory.
   *
   * <p>2) Count the number of chars and compare them.
   *
   * <p>The complex is O(n), but we need to allocate memory for the counters. If we are using the
   * Latin alphabet, we only need 26 counters, otherwise we unlikely to exceed more than 200,000
   * counters (there are 149,186 chars in Unicode, and we don't need special chars).
   *
   * <p>Let's do the math: 200,000 chars * 8 bytes (for long) * 1,000 parallel threads = 1.6 GB.
   * Having so bad conditions we will allocate 1.6 GB memory.
   *
   * <p>When it comes to backend this is nothing and RAM is cheaper than the CPU.
   *
   * <p>The problem that is more realistic is that we may have a text that is hundreds of gigabytes
   * in size. In this case we can't sort chars in memory.
   *
   * <p>The solution for this problem is below.
   */
  public static void main(String[] args) {
    isAnagram("file1.txt", "file2.txt");
  }

  public static boolean isAnagram(String fileName1, String fileName2) {
    final var counters1 = countChars(fileName1);
    final var counters2 = countChars(fileName2);
    return counters1.equals(counters2);
  }

  @SneakyThrows
  private static Map<Character, Long> countChars(String fileName) {
    final var file = new File(App.class.getResource("/" + fileName).getFile());
    final var counters = new HashMap<Character, Long>();
    if (file.length() == 0) {
      return counters;
    }
    try (final var reader = new BufferedReader(new FileReader(file))) {
      final var buf = createBuffer(file.length());
      var readChars = 0;
      while (readChars != -1) {
        readChars = reader.read(buf);
        countChars(buf, readChars, counters);
      }
    }
    return counters;
  }

  private static char[] createBuffer(long fileSize) {
    final var bufSize = 1_000_000;
    return new char[fileSize < bufSize ? (int) fileSize : bufSize];
  }

  private static void countChars(char[] buf, int readChars, Map<Character, Long> counters) {
    for (int i = 0; i < readChars; i++) {
      final var c = buf[i];
      if (Character.isWhitespace(c)) {
        continue;
      }
      counters.compute(Character.toLowerCase(c), (k, v) -> v == null ? 1L : v + 1);
    }
  }
}
